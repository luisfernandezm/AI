# -*- coding: utf-8 -*-
"""RNrecurrentes(stocks).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xg-pVBPy9ypUhXl8aYyl3AgMi4XeNN5p
"""

# Libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn .preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Dropout
from tensorflow.keras.callbacks import EarlyStopping
import yfinance as yf

# Companies
tickers = ['AAPL', 'GOOGL', 'TSLA', 'MSFT']
allData = {ticker: yf.download(ticker, start = '2020-01-01', end = '2023-01-01') for ticker in tickers}

# Dataframe
df = pd.DataFrame({ticker: data['Close'] for ticker, data in allData.items()})
print(df.head())

# Data visualization
df.plot(figsize = (15, 7))
plt.title('Close Price 2020 - 2023')
plt.ylabel('Close Price')
plt.xlabel('Date')
plt.legend(tickers)
plt.grid(True)
plt.show

# Save data in csv
for ticker, data in allData.items():
  data.to_csv(f'{ticker}-2020-2023')

# Scale data
scaler = MinMaxScaler(feature_range=(0, 1))
scaledData = scaler.fit_transform(data['Close'].values.reshape(-1, 1))

# Create sequences X, Y
X = []
Y = []

sequence = 60

for i in range(sequence, len(scaledData)):
    X.append(scaledData[i - sequence:i])
    Y.append(scaledData[i, 0])

X, Y = np.array(X), np.array(Y)

# Divide data
trainSize = int(0.8 * len(X))
Xtrain, Ytrain = X[:trainSize], Y[:trainSize]
Xtest, Ytest = X[trainSize:], Y[trainSize:]

Xtrain.shape, Xtest.shape

from sklearn.utils import validation
from scipy.optimize import optimize
# Building LSTM model
model = Sequential()

# First layer
model.add(LSTM(units = 50, return_sequences = True, input_shape = (Xtrain.shape[1], 1)))
model.add(Dropout(0.20))

# Second layer
model.add(LSTM(units = 50, return_sequences = True))
model.add(Dropout(0.20))

# Third layer
model.add(LSTM(units = 50))
model.add(Dropout(0.20))

# Last layer
model.add(Dense(units = 1))

# Compile model
model.compile(optimizer='adam', loss='mean_squared_error')

# Early Stopping
from keras.callbacks import EarlyStopping

# Early Stopping
EarlyStop = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
history = model.fit(Xtrain, Ytrain, epochs = 100, batch_size = 32, validation_data = (Xtest, Ytest), callbacks=[EarlyStop], verbose = 1)

# Loss function
loss = model.evaluate(Xtest, Ytest, verbose = 1)

# Price prediction

predictedPrices = model.predict(Xtest)
predictedPrices = scaler.inverse_transform(predictedPrices)

# Generar predicciones con modelo
predictedPricesScaled = model.predict(Xtest)
predictedPrices = scaler.inverse_transform(predictedPricesScaled)

# Inversi贸n de transformaci贸n de escala para obtener los precios reales en la escala original
realPrices = scaler.inverse_transform(Ytest.reshape(-1, 1))

# Visualizaci贸n de predicci贸nes vs Precios Reales
plt.figure(figsize = (14, 7))
plt.plot(data.index[-len(Ytest):], realPrices, label = 'Real Prices', color = 'blue')
plt.plot(data.index[-len(Ytest):], predictedPrices, label = 'Predictions', color = 'red', linestyle = 'dashed')
plt.title('Predictions vs Real Prices')
plt.xlabel('Date')
plt.ylabel('Closed Price ($)')
plt.legend()
plt.show()

# Cargar el conjunto de datos de Apple (AAPL)
data_aapl = pd.read_csv('/content/AAPL-2020-2023', date_parser=True)
data_aapl.set_index('Date', inplace=True)

# Escalar los datos
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data_aapl = scaler.fit_transform(data_aapl['Close'].values.reshape(-1, 1))

# Crear secuencias
X_aapl = []
y_aapl = []
sequence_length = 60
for i in range(sequence_length, len(scaled_data_aapl)):
    X_aapl.append(scaled_data_aapl[i-sequence_length:i])
    y_aapl.append(scaled_data_aapl[i, 0])

X_aapl, y_aapl = np.array(X_aapl), np.array(y_aapl)

# Dividir los datos en conjuntos de entrenamiento y prueba
train_size_aapl = int(0.8 * len(X_aapl))
X_train_aapl, y_train_aapl = X_aapl[:train_size_aapl], y_aapl[:train_size_aapl]
X_test_aapl, y_test_aapl = X_aapl[train_size_aapl:], y_aapl[train_size_aapl:]

# Predicciones con el modelo
predicted_prices_scaled_aapl = model.predict(X_test_aapl)
predicted_prices_aapl = scaler.inverse_transform(predicted_prices_scaled_aapl)

# Precios reales en la escala original
real_prices_aapl = scaler.inverse_transform(y_test_aapl.reshape(-1, 1))

# Visualizar predicciones vs precios reales
import matplotlib.pyplot as plt
plt.figure(figsize=(14, 7))
plt.plot(data_aapl.index[-len(y_test_aapl):], real_prices_aapl, label='Precios reales', color='blue')
plt.plot(data_aapl.index[-len(y_test_aapl):], predicted_prices_aapl, label='Predicciones', color='red', linestyle='dashed')
plt.title('Predicciones vs Precios reales (AAPL)')
plt.xlabel('Fecha')
plt.ylabel('Precio de cierre ($)')
plt.legend()
plt.show()